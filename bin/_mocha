#!/usr/bin/env node

/* eslint-disable no-var,vars-on-top,prefer-arrow-callback,prefer-template  */

function exitLater(code) {
  process.on('exit', function callback() {
    process.exit(code);
  });
}

function exit(code) {
  // flush output for Node.js Windows pipe bug
  // https://github.com/joyent/node/issues/6247 is just one bug example
  // https://github.com/visionmedia/mocha/issues/333 has a good discussion
  var draining = 0;
  var streams = [process.stdout, process.stderr];

  function done() {
    if (!(draining--)) process.exit(code);
  }

  streams.forEach(function callback(stream) {
    // submit empty write request and wait for completion
    draining += 1;
    stream.write('', done);
  });

  done();
}


var path = require('path');
var _ = require('lodash');

var configureMocha = require('../lib/mocha/configureMocha');
var resetMocha = require('../lib/mocha/resetMocha');

var webpackBuild = require('../lib/webpack/build');
var webpackWatch = require('../lib/webpack/watch');
var InjectChangedFilesPlugin = require('../lib/webpack/InjectChangedFilesPlugin');

var options = require('./options');

var files = options.files;

if (!files.length) {
  throw new Error('test entry is missing, please provide it!');
}

var entryFilePath = path.resolve(_.last(files));
var entryFileName = path.basename(entryFilePath);
var entryPath = path.dirname(entryFilePath);

var outputFilePath = path.join(process.cwd(), '.tmp', entryFileName);
var outputFileName = path.basename(outputFilePath);
var outputPath = path.dirname(outputFilePath);

var webpackConfigFile = path.resolve(options.webpackConfig);
var webpackConfig = _.clone(require(webpackConfigFile));

webpackConfig.entry = './' + entryFileName;
webpackConfig.context = entryPath;
webpackConfig.output = _.extend({}, webpackConfig.output, {
  filename: outputFileName,
  path: outputPath,
});

var injectChangedFilesPlugin = new InjectChangedFilesPlugin();
webpackConfig.plugins = (webpackConfig.plugins || []).concat([injectChangedFilesPlugin]);


var mocha = configureMocha(options);

if (options.watch) {
  var runAgain = false;
  var mochaRunner = null;

  function runMocha() { // eslint-disable-line no-inner-declarations
    // clear up require cache to reload test bundle
    delete require.cache[outputFilePath];

    resetMocha(mocha, options);
    mocha.files = [outputFilePath];

    runAgain = false;

    mochaRunner = mocha.run(function runCallback(failures) {
      injectChangedFilesPlugin.testsCompleted(failures > 0);

      // need to wait until next tick, otherwise mochaRunner = null doesn't work..
      process.nextTick(function nextTickCallback() {
        mochaRunner = null;
        if (runAgain) {
          runMocha();
        }
      });
    });
  }


  webpackWatch(webpackConfig, function callback(err) {
    if (err) {
      // wait for fixed tests
      return;
    }

    runAgain = true;

    if (mochaRunner) {
      mochaRunner.abort();
    } else {
      runMocha();
    }
  });
} else {
  webpackBuild(webpackConfig, function callback(err) {
    if (err) {
      return options.exit ? exit(1) : exitLater(1);
    }

    mocha.files = [outputFilePath];
    mocha.run(options.exit ? exit : exitLater);
  });
}
