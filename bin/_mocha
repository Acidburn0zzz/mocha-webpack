#!/usr/bin/env node

/* eslint-disable no-var,vars-on-top,prefer-arrow-callback,prefer-template  */

function exitLater(code) {
  process.on('exit', function callback() {
    process.exit(code);
  });
}

function exit(code) {
  // flush output for Node.js Windows pipe bug
  // https://github.com/joyent/node/issues/6247 is just one bug example
  // https://github.com/visionmedia/mocha/issues/333 has a good discussion
  var draining = 0;
  var streams = [process.stdout, process.stderr];

  function done() {
    if (!(draining--)) process.exit(code);
  }

  streams.forEach(function callback(stream) {
    // submit empty write request and wait for completion
    draining += 1;
    stream.write('', done);
  });

  done();
}


var path = require('path');
var fs = require('fs-extra');
var _ = require('lodash');
var isGlob = require('is-glob');
var globParent = require('glob-parent');
var hash = require('object-hash');
var anymatch = require('anymatch');

var exists = require('../lib/util/exists');
var configureMocha = require('../lib/mocha/configureMocha');
var resetMocha = require('../lib/mocha/resetMocha');

var contextReplacementPlugin = require('../lib/webpack/contextReplacementPlugin');
var prepareEntry = require('../lib/webpack/prepareEntry');
var webpackBuild = require('../lib/webpack/build');
var webpackWatch = require('../lib/webpack/watch');
var InjectChangedFilesPlugin = require('../lib/webpack/InjectChangedFilesPlugin');

var options = require('./options');

options.require.forEach(function requireModule(mod) {
  var absolute = exists.existsFileSync(mod) || exists.existsFileSync(mod + '.js');
  var file = absolute ? path.resolve(mod) : mod;
  require(file);
});

var files = options.files;

if (!files.length) {
  files.push('test/**.js');
}

var file = files[0];

var entryFilePath = null;
var outputFilePath = null;

var webpackPlugins = [];

var tmpPath = path.join(process.cwd(), '.tmp');

if (isGlob(file)) {
  var globPattern = file;
  var matcher = anymatch(globPattern);
  var parent = globParent(globPattern);
  var directory = path.resolve(parent);

  var context = path.relative(tmpPath, directory);

  var recursive = file.indexOf('**') !== -1;

  var bundleFileName = hash.MD5(options); // eslint-disable-line new-cap
  entryFilePath = path.join(tmpPath, bundleFileName + '-entry.js');
  outputFilePath = path.join(tmpPath, bundleFileName, bundleFileName + '-output.js');

  var fileContent = prepareEntry(context);
  fs.outputFileSync(entryFilePath, fileContent); // todo fix webpack runs twice...

  function matchModule(mod) { // eslint-disable-line no-inner-declarations
    // normalize path to match glob
    var correctedPath = path.join(parent, mod);
    return matcher(correctedPath);
  }
  webpackPlugins.push(contextReplacementPlugin(context, matchModule, recursive));
} else if (exists.existsDirSync(file)) {
  throw new Error('Directories are currently unsupported!');
} else if (exists.existsFileSync(file)) {
  entryFilePath = path.resolve(file);
  outputFilePath = path.join(tmpPath, path.basename(entryFilePath));
} else {
  throw new Error('File/Directory not found: ' + file);
}


var entryFileName = path.basename(entryFilePath);
var entryPath = path.dirname(entryFilePath);

var outputFileName = path.basename(outputFilePath);
var outputPath = path.dirname(outputFilePath);

var webpackConfigFile = path.resolve(options.webpackConfig);
var webpackConfig = _.clone(require(webpackConfigFile));

webpackConfig.entry = './' + entryFileName;
webpackConfig.context = entryPath;
webpackConfig.output = _.extend({}, webpackConfig.output, {
  filename: outputFileName,
  path: outputPath,
});

var injectChangedFilesPlugin = new InjectChangedFilesPlugin();
webpackPlugins.push(injectChangedFilesPlugin);

webpackConfig.plugins = (webpackConfig.plugins || []).concat(webpackPlugins);


var mocha = configureMocha(options);

if (options.watch) {
  var runAgain = false;
  var mochaRunner = null;

  function runMocha() { // eslint-disable-line no-inner-declarations
    // clear up require cache to reload test bundle
    delete require.cache[outputFilePath];

    resetMocha(mocha, options);
    mocha.files = [outputFilePath];

    runAgain = false;

    mochaRunner = mocha.run(function runCallback(failures) {
      injectChangedFilesPlugin.testsCompleted(failures > 0);

      // need to wait until next tick, otherwise mochaRunner = null doesn't work..
      process.nextTick(function nextTickCallback() {
        mochaRunner = null;
        if (runAgain) {
          runMocha();
        }
      });
    });
  }


  webpackWatch(webpackConfig, function callback(err) {
    if (err) {
      // wait for fixed tests
      return;
    }

    runAgain = true;

    if (mochaRunner) {
      mochaRunner.abort();
    } else {
      runMocha();
    }
  });
} else {
  webpackBuild(webpackConfig, function callback(err) {
    if (err) {
      return options.exit ? exit(1) : exitLater(1);
    }

    mocha.files = [outputFilePath];
    mocha.run(options.exit ? exit : exitLater);
  });
}
